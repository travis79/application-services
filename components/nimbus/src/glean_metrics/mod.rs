// -*- mode: Rust -*-

// AUTOGENERATED BY glean_parser.  DO NOT EDIT.

/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

pub mod nimbus_events {
    #[allow(unused_imports)] // HistogramType might be unusued, let's avoid warnings
    use glean::{private::*, traits::ExtraKeys, CommonMetricData, HistogramType, Lifetime};
    use once_cell::sync::Lazy;

    #[derive(Default, Debug, Clone, Hash, Eq, PartialEq)]
    pub struct EnrollmentExtra {
        pub branch: Option<String>,
        pub enrollment_id: Option<String>,
        pub experiment: Option<String>,
    }

    impl ExtraKeys for EnrollmentExtra {
        const ALLOWED_KEYS: &'static [&'static str] = &["branch", "enrollment_id", "experiment"];

        fn into_ffi_extra(self) -> ::std::collections::HashMap<i32, String> {
            let mut map = ::std::collections::HashMap::new();
            self.branch.and_then(|val| map.insert(0, val));
            self.enrollment_id.and_then(|val| map.insert(1, val));
            self.experiment.and_then(|val| map.insert(2, val));
            map
        }
    }

    #[allow(non_upper_case_globals, dead_code)]
    /// generated from nimbus_events.enrollment
    ///
    /// Recorded when a user has met the conditions and is first bucketed into an
    /// experiment (i.e. targeting matched and they were randomized into a bucket and
    /// branch of the experiment). Expected a maximum of once per experiment per user.
    pub static enrollment: Lazy<EventMetric<EnrollmentExtra>> = Lazy::new(|| {
        EventMetric::new(CommonMetricData {
            category: "nimbus_events".into(),
            name: "enrollment".into(),
            send_in_pings: vec!["events".into()],
            lifetime: Lifetime::Ping,
            disabled: false,
            ..Default::default()
        })
    });

    #[derive(Default, Debug, Clone, Hash, Eq, PartialEq)]
    pub struct UnenrollmentExtra {
        pub branch: Option<String>,
        pub enrollment_id: Option<String>,
        pub experiment: Option<String>,
    }

    impl ExtraKeys for UnenrollmentExtra {
        const ALLOWED_KEYS: &'static [&'static str] = &["branch", "enrollment_id", "experiment"];

        fn into_ffi_extra(self) -> ::std::collections::HashMap<i32, String> {
            let mut map = ::std::collections::HashMap::new();
            self.branch.and_then(|val| map.insert(0, val));
            self.enrollment_id.and_then(|val| map.insert(1, val));
            self.experiment.and_then(|val| map.insert(2, val));
            map
        }
    }

    #[allow(non_upper_case_globals, dead_code)]
    /// generated from nimbus_events.unenrollment
    ///
    /// Recorded when either telemetry is disabled, or the experiment has run for its
    /// designed duration (i.e. it is no longer present in the Nimbus Remote Settings
    /// collection)
    pub static unenrollment: Lazy<EventMetric<UnenrollmentExtra>> = Lazy::new(|| {
        EventMetric::new(CommonMetricData {
            category: "nimbus_events".into(),
            name: "unenrollment".into(),
            send_in_pings: vec!["events".into()],
            lifetime: Lifetime::Ping,
            disabled: false,
            ..Default::default()
        })
    });

    #[derive(Default, Debug, Clone, Hash, Eq, PartialEq)]
    pub struct DisqualificationExtra {
        pub branch: Option<String>,
        pub enrollment_id: Option<String>,
        pub experiment: Option<String>,
        pub reason: Option<String>,
    }

    impl ExtraKeys for DisqualificationExtra {
        const ALLOWED_KEYS: &'static [&'static str] = &["branch", "enrollment_id", "experiment", "reason"];

        fn into_ffi_extra(self) -> ::std::collections::HashMap<i32, String> {
            let mut map = ::std::collections::HashMap::new();
            self.branch.and_then(|val| map.insert(0, val));
            self.enrollment_id.and_then(|val| map.insert(1, val));
            self.experiment.and_then(|val| map.insert(2, val));
            self.reason.and_then(|val| map.insert(3, val));
            map
        }
    }

    #[allow(non_upper_case_globals, dead_code)]
    /// generated from nimbus_events.disqualification
    ///
    /// Recorded when a user becomes ineligible to continue receiving the treatment for
    /// an enrolled experiment, for reasons such as the user opting out of the
    /// experiment or no longer matching targeting for the experiment.
    pub static disqualification: Lazy<EventMetric<DisqualificationExtra>> = Lazy::new(|| {
        EventMetric::new(CommonMetricData {
            category: "nimbus_events".into(),
            name: "disqualification".into(),
            send_in_pings: vec!["events".into()],
            lifetime: Lifetime::Ping,
            disabled: false,
            ..Default::default()
        })
    });

    #[derive(Default, Debug, Clone, Hash, Eq, PartialEq)]
    pub struct ExposureExtra {
        pub branch: Option<String>,
        pub enrollment_id: Option<String>,
        pub experiment: Option<String>,
    }

    impl ExtraKeys for ExposureExtra {
        const ALLOWED_KEYS: &'static [&'static str] = &["branch", "enrollment_id", "experiment"];

        fn into_ffi_extra(self) -> ::std::collections::HashMap<i32, String> {
            let mut map = ::std::collections::HashMap::new();
            self.branch.and_then(|val| map.insert(0, val));
            self.enrollment_id.and_then(|val| map.insert(1, val));
            self.experiment.and_then(|val| map.insert(2, val));
            map
        }
    }

    #[allow(non_upper_case_globals, dead_code)]
    /// generated from nimbus_events.exposure
    ///
    /// Recorded when a user actually observes an experimental treatment, or would have
    /// observed an experimental treatment if they had been in a branch that would have
    /// shown one.
    pub static exposure: Lazy<EventMetric<ExposureExtra>> = Lazy::new(|| {
        EventMetric::new(CommonMetricData {
            category: "nimbus_events".into(),
            name: "exposure".into(),
            send_in_pings: vec!["events".into()],
            lifetime: Lifetime::Ping,
            disabled: false,
            ..Default::default()
        })
    });
}

